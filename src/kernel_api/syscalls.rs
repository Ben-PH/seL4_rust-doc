//! Direct kernel interface. When invoked with a capability, allows for IPC communication and use of kernel objects.
//!
//! Threads send messages by invoking capabilities within their capability space. When
//! an [EndPoint], [Notification] or [Reply] capability is invoked in this way, the message will be
//! transferred through the kernel to another thread. When other capabilities to kernel
//! objects are invoked, the message will be interpreted as a method invocation in a manner
//! specific to the type of kernel object. For example, a thread of execution can be suspended by invoking a  [ThreadControlBlock]
//! (TCB) capability with the correctly formatted message.
//!
//! Much how libc can simplify usage of a POSIX api by acting as a layer between the user and the system api itself, libsel4 acts as a layer between the user and these syscalls. For example, configuring a TCB requires the setting of 3 specific capabilities and 4 variable values in the MessageInfo. This is handled by libsel4 `seL4_TCB_Configure`.
//!
//!
//! With the exception of `yield`, there are only two syscalls: `send` and `recv`, with the others being only slight variations/combinations of these two.

#![allow(unused_variables)]
use crate::types::*;

#[cfg(doc)]
use crate::types::capabilities::*;
/// Delivers msg through named cap & the app to continue
///
/// If cap is an endpoint, && no recver ready, will block
/// blocks until msg can be delivered
pub fn send(reciever: CapPtr, msg: MessageInfo) -> () {
    unimplemented!()
}
/// Polling send on an endpoint
///
/// like `send`, with key difference:
///  * instead of a block, message will silently drop
pub fn nb_send(reciever: CapPtr, msg: MessageInfo) -> () {
    unimplemented!()
}

/// Recieves message.
///
/// Blocks if no sender or notification pending
/// Limited to end-point and ntfn caps
/// Raises fault with other cap types (sel4 manual: 6.2)
/// if get_badge, returns (_, Some(badge_number)) to get
/// info on where it came from
pub fn recv(endpoint: CapPtr, get_badge: bool) -> (MessageInfo, Option<Badge>) {
    unimplemented!()
}

/// As with `recv`, but does not block.
pub fn nb_recv(endpoint: CapPtr, get_badge: bool) -> (MessageInfo, Option<Badge>) {
    unimplemented!()
}

/// Combine send and recv with key difference
///
///  * On caps to non-endpoint kernel-services, can ret
///    an error, or other msg through the reply
///  * When sent msg goes to another thread (via end-point),
///    as well as the normal `send`, the kernal also deposits
///    a reply cap to a dedicated slot in the recieving TCB
///   * A reply cap is single-use cap allowing for a reply msg
///     to be sent and wake up the caller (and invalidated by
///     the kernel once used.
///
/// See also section 4.2.4 of the sel4 manual
pub fn call(invoked_cap: CapPtr, info: MessageInfo) -> MessageInfo {
    unimplemented!()
}

/// Uses reply cap generated by `call()` to respond to it.
///
/// Same behaviour as using the cap with `send()`(sel4 manual: 4.2.4)
pub fn reply(msg: MessageInfo) -> () {
    unimplemented!()
}

/// High performance chaining of `reply()` then `recv()` with
/// atomic transition between repyl and recv phase
pub fn reply_recv(
    invoked_cap: CapPtr,
    info: MessageInfo,
    get_badge: bool,
) -> (MessageInfo, Option<Badge>) {
    unimplemented!()
}

/// only cap-free sys-call.
///
/// forfiets remaineder of calling threads time-slite, then
/// kernel scheduler is invoked as a result.
/// If no other threads with matching priority, the calling
/// thread is immediately rescheduled w/ fresh timeslice.
pub fn r#yield() {
    unimplemented!()
}
