use crate::primitives::*;
use crate::cspace::CapPtr;
use crate::MessageInfo;
pub trait SysCall {
    ///
    /// Delivers msg through named cap & the app to continue
    /// if cap is an endpoint, && no recver ready, will block
    /// blocks until msg can be delivered
    fn send(reciever: CapPtr, msg: MessageInfo) -> () {unimplemented!()}
    /// Polling send on an endpoint
    /// like `send`, with key difference:
    ///  * instead of a block, message will silently drop
    fn nb_send(reciever: CapPtr, msg: MessageInfo) -> () {unimplemented!()}

    /// Rocieves message.
    /// Blocks if no sender or notification pending
    /// Limited to end-point and ntfn caps
    /// Raises fault with other cap types (sel4 manual: 6.2)
    /// if get_badge, returns (_, Some(bade_number)) to get
    /// info on where it came from
    fn recv(
        endpoint: CapPtr,
        get_badge: bool
    ) -> (MessageInfo, Option<Badge>) {unimplemented!()}

    /// As with `recv`, but does not block.
    fn nb_recv(
        endpoint: CapPtr,
        get_badge: bool
    ) -> (MessageInfo, Option<Badge>) {unimplemented!()}

    /// Combine send and recv with key difference
    ///  * On caps to non-endpoint kernel-services, can ret
    ///    an error, or other msg through the reply
    ///  * When sent msg goes to another thread (via end-point),
    ///    as well as the normal `send`, the kernal also deposits
    ///    a reply cap to a dedicated slot in the recieving TCB
    ///   * A reply cap is single-use cap allowing for a reply msg
    ///     to be sent and wake up the caller (and invalidated by
    ///     the kernel once used.
    ///
    /// See also section 4.2.4 of the sel4 manual
    fn call(invoked_cap: CapPtr, info: MessageInfo) -> MessageInfo {unimplemented!()}

    /// Uses reply cap generated by `call()` to respond to it.
    /// Same behaviour as using the cap with `send()`(sel4 manual: 4.2.4)
    fn reply(msg: MessageInfo) -> () {unimplemented!()}

    /// High performance chaining of `reply()` then `recv()` with
    /// atomic transition between repyl and recv phase
    fn reply_recv(
        invoked_cap: CapPtr,
        info: MessageInfo,
        get_badge: bool,
    ) -> (MessageInfo, Option<Badge>){unimplemented!()}

    /// only cap-free sys-call.
    /// forfiets remaineder of calling threads time-slite, then
    /// kernel scheduler is invoked as a result.
    /// If no other threads with matching priority, the calling
    /// thread is immediately rescheduled w/ fresh timeslice.
    fn r#yield(){unimplemented!()}
}
