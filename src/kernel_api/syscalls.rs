//! Raw kernel interface. When invoked with a capability, allows for IPC communication and use of kernel objects.
//!
//! Threads send messages by invoking capabilities within their capability space. When
//! an [EndPoint], [Notification] or [Reply] capability is invoked in this way, the message will be
//! transferred through the kernel to another thread. When capabilities to other kernel
//! objects are invoked, the message will be interpreted as a method invocation in a manner
//! specific to the type of kernel object. For example, a thread of execution can be suspended by invoking a  [ThreadControlBlock]
//! (TCB) capability with the correctly formatted message.
//!
//! Much how libc can simplify usage of a POSIX api by acting as a layer between the user and the system api itself, libsel4 acts as a layer between the user and these syscalls. For example, configuring a TCB requires the setting of 3 specific capabilities and 4 variable values in the message::Info. This is handled by libsel4 `seL4_TCB_Configure`.
//!
//!
//! With the exception of `yield`, there are only two syscalls: `send` and `recv`, with the others being only slight variations/combinations of these two.

#![allow(unused_variables)]

#[cfg(doc)]
use crate::kernel_api::object_interfaces::{
    thread_control_block::ThreadControlBlock,
    endpoints::EndPoint,
    notifications::Notification,
    reply::Reply
};
use crate::types::SeL4Error;
use crate::types::capabilities::Capability;
use crate::types::{Badge, message};
use core::convert::TryFrom;


/// Syscalls that send on a capability.
pub trait SeL4Send: Capability  {
    /// Delivers msg through named cap & the app to continue
    ///
    /// If cap is an endpoint, && no recver ready, will block
    /// blocks until msg can be delivered
    fn send(&self, msg: message::Info);
    /// Polling send on an endpoint
    ///
    /// like `send`, with key difference:
    ///  * instead of a block, message will silently drop
    fn nb_send(&self, msg: message::Info);
}

/// Uses reply cap generated by `call()` to respond to it.
///
/// Same behaviour as using the cap with `send()`(sel4 manual: 4.2.4)
pub fn reply(msg: message::Info) {
    unimplemented!()
}

/// Syscalls that recieve on a capability
pub trait SeL4Recv: Capability {
    /// Recieves message.
    ///
    /// Blocks if no sender or notification pending
    /// Limited to end-point and ntfn caps
    /// Raises fault with other cap types (sel4 manual: 6.2)
    /// if get_badge, returns (_, Some(badge_number)) to get
    /// info on where it came from
    fn recv(&self, get_badge: Option<&mut Badge>) -> message::Info;

    /// As with `recv`, but does not block.
    fn nb_recv(&self, get_badge: Option<&mut Badge>) -> message::Info;

    /// High performance chaining of `reply()` then `recv()` with
    /// atomic transition between repyl and recv phase
    fn reply_recv(
        &self,
        info: message::Info,
        badge: Option<&mut Badge>,
    ) -> message::Info;
}

/// Allows send and recieve in a single call, thus improving performance.
pub trait SeL4SendRecv: SeL4Send + SeL4Recv {
    /// Combine send and recv with key difference
    ///
    ///  * On caps to non-endpoint kernel-services, can ret
    ///    an error, or other msg through the reply
    ///  * When sent msg goes to another thread (via end-point),
    ///    as well as the normal `send`, the kernal also deposits
    ///    a reply cap to a dedicated slot in the recieving TCB
    ///   * A reply cap is single-use cap allowing for a reply msg
    ///     to be sent and wake up the caller (and invalidated by
    ///     the kernel once used.
    ///
    /// See also section 4.2.4 of the sel4 manual
    fn call(&self, info: message::Info) -> message::Info;

}

/// only cap-free sys-call.
///
/// forfiets remaineder of calling threads time-slite, then
/// kernel scheduler is invoked as a result.
/// If no other threads with matching priority, the calling
/// thread is immediately rescheduled w/ fresh timeslice.
fn yield_() {
    unimplemented!()
}

/// A wraps a [message::Info]. Used to error check a syscall result.
///
///
struct SysResult {
    inner: message::Info,
}
pub type SeL4Result<T> = Result<T, SeL4Error>;
impl TryFrom<SysResult> for message::Info {
    type Error = crate::types::err::SeL4Error;
    fn try_from(val: SysResult) -> SeL4Result<Self> {
        unimplemented!()
    //     use crate::types::err::SeL4Error::*;
    //     match val.inner.label().0 {
    //         0 => Ok(message::Info::default()),
    //         1 => Err(InvalidArgument(panic!("get IPCBuffer[0]"))),
    //         2 => Err(InvalidCapability(panic!("get IPCBuffer[0]"))),
    //         3 => Err(IllegalOperation),
    //         4 => Err(RangeError(panic!(
    //             "get IPCBuffer[0, 2], and make a range error"
    //         ))),
    //         5 => Err(AlignmentError),
    //         6 => Err(FailedLookup(panic!(
    //             "get IPCBuffer[0, 2, ...], and make a lookup failure error"
    //         ))),
    //         7 => Err(TruncatedMessage),
    //         8 => Err(DeleteFirst),
    //         9 => Err(RevokeFirst),
    //         10 => Err(NotEnoughMemory(panic!("get IPCBuffer[0]"))),
    //         _ => unreachable!("the C libraries error enum should only be 0..=10"),
    //     }
    }
}
